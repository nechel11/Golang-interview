map golang (https://www.youtube.com/watch?v=P_SXTUiA-9Y&t=2s)

	"Как реализована map(карта) go?"
		Сама map в go - это структура, реализующая операции хеширования. 
		При этом, так же как и любую структуру, содержащую ссылки на области памяти,map необходимо инициализировать. 
		map ссылается на такие элементы как bucket (в переводе на русский "ведра"). 
		Каждый bucket содержит в себе:
		8 экстра бит, с помощью которых осуществляется доступ до значений в этом bucket;
		ссылку на следующий коллизионный bucket;
		8 пар ключ-значение, уложенных в массив.
		
		type hmap struct {
			count     int // # live cells == size of map.  Must be first (used by len() builtin)
			flags     uint8
			B         uint8  // log_2 of # of buckets (can hold up to loadFactor * 2^B items)
			noverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details
			hash0     uint32 // hash seed
			buckets    unsafe.Pointer // array of 2^B Buckets. may be nil if count==0.
			oldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing
			nevacuate  uintptr        // progress counter for evacuation (buckets less than this have been evacuated)
			extra *mapextra // optional fields
		}

	"Почему нельзя брать ссылку на значение, хранящееся по ключу в map?"
		map поддерживает процедуру эвакуации. 
		Значения, хранящиеся в определённой ячейки памяти в текущий момент времени, 
		в следующий момент времени уже могут там не храниться.

	"Что такое эвакуация, и в каком случае она будет происходить?"
		Эвакуация - это процесс когда map переносит свои значения из одной области памяти в другую. 
		Это происходит из-за того что число значений в каждом отдельном bucket максимально равно 8.
		В тот момент времени, когда среднее количество значений в bucket составляет 6.5, 
		go понимает, что размер map не удовлетворяет необходимому. Начинается процесс расширения map.
		Следует отметить, что сам процесс эвакуации может происходить некоторое время, 
		на протяжение которого новые и старые данные будут связаны.

	"Какие есть особенности синтаксиса получения и записи значений в map?"
		Получить значение из map, которую мы предварительно не аллоцировали нельзя, приложение упадет в панику.
		Если ключ не найден в map в ответ мы получим дефолтное значение для типа значений map. 
		То есть, для строки - это будет пустая строка, для int - 0 и так далее. 
		Для того, чтобы точно понять, что в map действительно есть значение, хранящееся по переданному ключу, необходимо использовать специальный синтаксис. 
		А именно, возвращать не только само значение, но и булевую переменную, которая показывает удалось-ли получить значение по ключу.

	"Как происходит поиск по ключу в map?"
		вычисляется хэш от ключа;
    	с помощью значения хэша и размера bucket вычисляется используемый для хранения bucket;
    	вычисляется дополнительный хэш - это первые 8 бит уже полученного хэша;
		в полученном bucket последовательно сравнивается каждый из 8 его дополнительных хэшей с дополнительным хэшем ключа;
		если дополнительные хэши совпали, то получаем ссылку на значение и возвращаем его;
		если дополнительные хэши не совпали, и в bucket больше нет дополнительных хэшей, алгоритм переходит в следующий bucket, ссылка на который хранится в текущем;
		если в текущем bucket нет ссылки на следующий bucket, а значение так и не найдено, возвращается дефолтное значение.
			
	"Свойства хэш-функции"
		Равномерность - записи равномерно распределены по бакетам
		Быстрота - быстро вычислять ключ
		Детерминированность - для одного ключа один и тот же номер бакета