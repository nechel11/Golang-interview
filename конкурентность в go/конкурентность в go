Конкурентность в Golang
https://clck.ru/sUEwK

	"Что такое асинхронность?"
		Вычисления в системе могут идти двумя способами:
		синхронно - это когда код выполняется последовательно;
		асинхронно - это когда операцию мы можем выполнять не дожидаясь результата на месте. 
		Обычно подразумевается, что операция может быть выполнена кем-то на стороне.

	"Что такое параллельность?"
		Вычисления будут являться параллельным только в том случае, если они выполняются одновременно. 
		Как пример можно привести процесс ремонта в доме. 
		У нас есть несколько мастеров-универсалов, 
		каждый из которых выполняет работы на своем объекте под ключ. 
		При этом производительность мастеров не зависит друг от друга, 
		так как их работа не пересекается.

	"Что такое процесс"
		Процесс - это экземпляр программы, которая запущена в операционной системе. 
		Каждый процесс имеет свою собственную память и ресурсы, такие как файлы, сетевые соединения и т.д. 
		Один процесс может запускать несколько потоков.

	"Что такое thread?"
		Поток - это легковесный подпроцесс, который работает внутри процесса. 
		Каждый поток имеет свой собственный стек и указатель инструкций, 
		но разделяет память и ресурсы с другими потоками внутри процесса. 
		Потоки обычно используются для параллельной обработки задач внутри одного процесса 
		и позволяют улучшить производительность приложения.

	"Разница процесса и потока"
		Разница между процессом и потоком заключается в том, что процесс - это экземпляр программы, 
		который имеет свою собственную память и ресурсы, тогда как поток - это легковесный подпроцесс, 
		который работает внутри процесса и разделяет память и ресурсы с другими потоками внутри процесса.

	"Что такое goroutine?"
		Горутина - реализация в Go корутины, блоков кода, которые работают асинхронно. 
		Она объявляется через оператор go перед функцией, 
		вычисления которой необходимо сделать асинхронными. 
		На многоядерной архитектуре выполнение горутин можно осуществлять на разных ядрах процессора. 
		Это сделает эти вычисления параллельными и может сильно ускорить вычисления.

	"Какие основные отличия горутины от thread?"
		Горутина :
			-Управляются рантаймом языка => Более высокоуровневая абстракция, поэтому не зависит от системы
			-Более легковесны => Имеет стэк, который может расти
		Поток :
			-Управляются процессорным ядром => Зависит от системы
			-Требуют большего количества ресурсов => Фиксированный стэк
	
	"Каков минимальный и максимальный вес горутин?"
		для x64 - 1гб
		для х32 - 250мб

	"Что будет если размер горутины превысил допустимый максимум?"
		Если размер стэка горутины превышен (к примеру запустили бесконечную рекурсию), то приложение упадет с fatal error.
	
	"Какое максимальное количество горутин может быть запущено в системе?"
		Количество горутин ограничено только оперативной памятью системы.
	
	"Что такое планировщик go?"
		Рантайм (runtime) — «обслуживающая» часть приложения, которая добавляется к коду приложения. 
		Отвечает за взаимодействие с ОС, планированием выполнения приложения, сборку мусора и за другие поддерживающие операции.
		
		Планировщик — часть рантайма, которая управляет запуском и остановкой горутин, решает, 
		в каком порядке будут выполняться горутины, осуществляет взаимодействие с тредами ОС. 

	"Какие есть способы остановить все горутины в приложении?"
		завершение main функции и main горутины;

   		прослушивание всеми горутинами channel, при закрытии channel отправляется значение по умолчанию всем слушателям, при получении сигнала все горутины делают return;

   		завязать все горутины на переданный в них context.

	"Как наладить связь между горутинами?"
		Каналы  обеспечивают возможность общения нескольких горутин друг с другом, чтобы синхронизировать их выполнение.

		Многопоточная работа - работа нескольких потоков. При этом не факт, что все потоки будут активны. 
		Возможно, что работает один поток, а другой спит. Когда первый поток закончил работу, он может разбудить второй, а сам заснуть

		Распараллеливание - разбиение одной задачи на независимые подзадачи и выполнение этих подзадач одновременно разными потоками. 
		Пример: вычисление среднего значения двумерного массива. Каждый поток может посчитать сумму своей строки, а потом все это объединить

		Асинхронная работа - когда мы ставим какую-то задачу, но не ждем ответа, а продолжаем делать свою работу. А когда будет готов ответ - нас уведомят. 
		Пример: попросить секретаря сварить кофе. Мы не ждем этого кофе и занимаемся своими делами, а когда кофе будет готов - нам его принесут.

	"race condition что это"
		Race condition - это ситуация, когда два или более процесса или потока исполнения пытаются изменить общие ресурсы одновременно, 
		что может привести к неожиданным и непредсказуемым результатам. 

		Это происходит, когда порядок выполнения операций не определен, 
		и разные процессы могут попытаться изменить один и тот же ресурс одновременно, 
		что может привести к ошибкам в программе или к неправильным результатам. 

		Например, если два потока одновременно пытаются увеличить значение переменной на единицу, 
		то результат может быть непредсказуемым, так как оба потока могут прочитать изначальное значение переменной и увеличить его на единицу, 
		но только одно из них сохранит измененное значение, что может привести к некорректному результату.

		Для предотвращения race condition необходимо использовать механизмы синхронизации, 
		такие как блокировки, мьютексы и семафоры, чтобы гарантировать, 
		что только один процесс или поток исполнения может изменять ресурс в определенный момент времени.

	"deadlock"
		Deadlock (заглушка) - это ситуация, которая возникает в многопоточном или распределенном приложении,
		когда два или более потока блокируют друг друга, ожидая освобождения ресурсов,
		которые заняты другими потоками. В результате ни один из потоков не может продолжить выполнение своих задач.

		Deadlock может возникнуть, когда два или более потока одновременно запрашивают ресурсы,
		которые уже заняты другими потоками, и не отпускают их, пока не получат доступ.
		В результате возникает зацикленная ситуация, когда каждый поток ждет,
		чтобы другой поток освободил ресурсы, которые ему нужны.

		Примером deadlock может быть ситуация, когда поток A заблокировал ресурс X и запрашивает доступ к ресурсу Y,
		который заблокировал поток B. В то же время поток B запрашивает доступ к ресурсу X,
		который заблокировал поток A. В результате оба потока блокируют друг друга и не могут продолжить выполнение своих задач.

		Для предотвращения deadlock необходимо использовать правильный подход к управлению ресурсами и блокировками.
		Например, можно использовать стратегии предоставления ресурсов,
		которые минимизируют конфликты и блокировки, или использовать алгоритмы,
		которые позволяют избежать зацикливания.
		Кроме того, можно использовать средства мониторинга и диагностики,
		которые позволяют обнаруживать и исправлять deadlock в реальном времени.
	